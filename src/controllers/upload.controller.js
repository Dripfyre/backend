const { v4: uuidv4 } = require('uuid');
const storageService = require('../services/storage.service');
const sessionService = require('../services/session.service');
const aiService = require('../services/ai.service');
const logger = require('../utils/logger');

/**
 * Upload media files
 */
const uploadMedia = async (req, res, next) => {
  try {
    const { sessionId } = req.params;
    console.log("ðŸš€ ~ uploadMedia ~ sessionId:", sessionId)
    const files = req.files || [req.file];

    if (!files || files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No files uploaded',
      });
    }

    // Get existing session and clean up old images
    const existingSession = await sessionService.getSession(sessionId);
    if (existingSession && existingSession.metadata.uploadedMedia.length > 0) {
      logger.info(`Cleaning up ${existingSession.metadata.uploadedMedia.length} old images for session ${sessionId}`);
      
      // Delete old uploaded images from storage
      for (const media of existingSession.metadata.uploadedMedia) {
        try {
          await storageService.deleteFile(media.url);
          logger.info(`Deleted old image: ${media.url}`);
        } catch (error) {
          logger.error(`Error deleting old image ${media.url}:`, error);
        }
      }
      
      // Delete old processed images from storage if they exist
      if (existingSession.metadata.processedContent?.processedMedia) {
        for (const processedUrl of existingSession.metadata.processedContent.processedMedia) {
          try {
            // Only delete if it's different from uploaded media
            const isUploadedMedia = existingSession.metadata.uploadedMedia.some(m => m.url === processedUrl);
            if (!isUploadedMedia) {
              await storageService.deleteFile(processedUrl);
              logger.info(`Deleted old processed image: ${processedUrl}`);
            }
          } catch (error) {
            logger.error(`Error deleting old processed image ${processedUrl}:`, error);
          }
        }
      }
      
      // Clear old media and processed content from session
      existingSession.metadata.uploadedMedia = [];
      existingSession.metadata.processedContent = null;
      await sessionService.updateSession(sessionId, existingSession);
      
      logger.info(`Cleared old images from session ${sessionId}`);
    }

    const uploadedFiles = [];

    for (const file of files) {
      if (!file) continue;

      // Upload file to storage
      const uploadResult = await storageService.uploadFile(file, 'uploads');

      const mediaInfo = {
        mediaId: uuidv4(),
        fileId: uploadResult.fileId,
        fileName: uploadResult.fileName,
        url: uploadResult.url,
        mimeType: uploadResult.mimeType,
        size: uploadResult.size,
        uploadedAt: new Date().toISOString(),
      };
      console.log("ðŸš€ ~ uploadMedia ~ mediaInfo:", mediaInfo)

      // Add to session
      await sessionService.addMediaToSession(sessionId, mediaInfo);

      uploadedFiles.push(mediaInfo);
    }

    logger.info(`Uploaded ${uploadedFiles.length} files for session ${sessionId}`);

    // Fast auto-generation using AI service (2-3 seconds)
    let autoGeneratedContent = null;
    try {
      logger.info(`Fast-generating content for session ${sessionId}`);
      
      // Get the first image buffer to analyze
      const firstImageFile = files.find(f => f && f.mimetype.startsWith('image/'));
      const imageData = firstImageFile
        ? { buffer: firstImageFile.buffer, mimeType: firstImageFile.mimetype }
        : null;
      console.log("ðŸš€ ~ uploadMedia ~ imageData:", imageData)
      
      // Generate caption and hashtags in one fast call (with actual image analysis!)
      const result = await aiService.generateInitialContent(imageData, 'lifestyle');
      
      // Store auto-generated content in session
      autoGeneratedContent = {
        intent: {
          rawTranscript: 'Auto-generated from uploaded image',
          action: 'create_post',
          platform: 'instagram',
        },
        transcript: 'Auto-generated from uploaded image',
        caption: result.caption,
        captionVariations: [],
        hashtags: result.hashtags.split(' '),
        hashtagsFormatted: result.hashtags,
        processedMedia: uploadedFiles.map(m => m.url),
        originalMedia: uploadedFiles.map(m => m.url),
        processedAt: new Date().toISOString(),
        autoGenerated: true,
        voiceEdited: false,
      };
      
      await sessionService.storeProcessedContent(sessionId, autoGeneratedContent);
      
      logger.info(`Fast-generated content stored for session ${sessionId}`, {
        captionLength: result.caption.length,
        hashtagCount: result.hashtags.split(' ').length,
      });
    } catch (error) {
      logger.error('Fast-generation error:', error);
      // Continue even if auto-generation fails
    }

    // Convert uploaded files to base64 for response
    const fs = require('fs');
    const path = require('path');
    const imagesWithBase64 = [];
    
    for (const file of uploadedFiles) {
      try {
        const filePath = path.join(process.cwd(), file.url);
        if (fs.existsSync(filePath)) {
          const imageBuffer = fs.readFileSync(filePath);
          const base64 = imageBuffer.toString('base64');
          const mimeType = file.mimeType;
          
          imagesWithBase64.push({
            url: file.url,
            base64: `data:${mimeType};base64,${base64}`,
            mimeType: mimeType,
          });
        }
      } catch (error) {
        logger.error(`Error converting image to base64: ${file.url}`, error);
      }
    }

    // Return simple response matching sync API format
    res.status(201).json({
      success: true,
      data: {
        sessionId,
        images: imagesWithBase64,
        caption: autoGeneratedContent?.caption || null,
        hashtags: autoGeneratedContent?.hashtagsFormatted || '',
      },
    });
  } catch (error) {
    logger.error('Upload media error:', error);
    next(error);
  }
};

module.exports = {
  uploadMedia,
};

