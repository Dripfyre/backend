const { v4: uuidv4 } = require('uuid');
const storageService = require('../services/storage.service');
const sessionService = require('../services/session.service');
const coordinatorAgent = require('../agents/coordinator.agent');
const logger = require('../utils/logger');

/**
 * Upload media files
 */
const uploadMedia = async (req, res, next) => {
  try {
    const { sessionId } = req.params;
    console.log("ðŸš€ ~ uploadMedia ~ sessionId:", sessionId)
    const files = req.files || [req.file];

    if (!files || files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No files uploaded',
      });
    }

    // Get existing session and clean up old images
    const existingSession = await sessionService.getSession(sessionId);
    if (existingSession && existingSession.metadata.uploadedMedia.length > 0) {
      logger.info(`Cleaning up ${existingSession.metadata.uploadedMedia.length} old images for session ${sessionId}`);
      
      // Delete old uploaded images from storage
      for (const media of existingSession.metadata.uploadedMedia) {
        try {
          await storageService.deleteFile(media.url);
          logger.info(`Deleted old image: ${media.url}`);
        } catch (error) {
          logger.error(`Error deleting old image ${media.url}:`, error);
        }
      }
      
      // Delete old processed images from storage if they exist
      if (existingSession.metadata.processedContent?.processedMedia) {
        for (const processedUrl of existingSession.metadata.processedContent.processedMedia) {
          try {
            // Only delete if it's different from uploaded media
            const isUploadedMedia = existingSession.metadata.uploadedMedia.some(m => m.url === processedUrl);
            if (!isUploadedMedia) {
              await storageService.deleteFile(processedUrl);
              logger.info(`Deleted old processed image: ${processedUrl}`);
            }
          } catch (error) {
            logger.error(`Error deleting old processed image ${processedUrl}:`, error);
          }
        }
      }
      
      // Clear old media and processed content from session
      existingSession.metadata.uploadedMedia = [];
      existingSession.metadata.processedContent = null;
      await sessionService.updateSession(sessionId, existingSession);
      
      logger.info(`Cleared old images from session ${sessionId}`);
    }

    const uploadedFiles = [];

    for (const file of files) {
      if (!file) continue;

      // Upload file to storage
      const uploadResult = await storageService.uploadFile(file, 'uploads');

      const mediaInfo = {
        mediaId: uuidv4(),
        fileId: uploadResult.fileId,
        fileName: uploadResult.fileName,
        url: uploadResult.url,
        mimeType: uploadResult.mimeType,
        size: uploadResult.size,
        uploadedAt: new Date().toISOString(),
      };
      console.log("ðŸš€ ~ uploadMedia ~ mediaInfo:", mediaInfo)

      // Add to session
      await sessionService.addMediaToSession(sessionId, mediaInfo);

      uploadedFiles.push(mediaInfo);
    }

    logger.info(`Uploaded ${uploadedFiles.length} files for session ${sessionId}`);

    // Fast auto-generation using LiteLLM service (2-3 seconds)
    let autoGeneratedContent = null;
    try {
      logger.info(`Fast-generating content for session ${sessionId}`);
      
      const litellmService = require('../services/litellm.service');
      
      // Get the first image buffer to analyze
      const firstImageFile = files.find(f => f && f.mimetype.startsWith('image/'));
      const imageData = firstImageFile
        ? { buffer: firstImageFile.buffer, mimeType: firstImageFile.mimetype }
        : null;
      console.log("ðŸš€ ~ uploadMedia ~ imageData:", imageData)
      
      // Generate caption and hashtags in one fast call (with actual image analysis!)
      const result = await litellmService.generateCaptionAndHashtags({
        theme: 'lifestyle',
        platform: 'instagram',
      }, imageData);
      
      // Store auto-generated content in session
      autoGeneratedContent = {
        intent: {
          rawTranscript: 'Auto-generated from uploaded image',
          action: 'create_post',
          platform: 'instagram',
        },
        transcript: 'Auto-generated from uploaded image',
        caption: result.caption,
        captionVariations: [],
        hashtags: result.hashtags.split(' '),
        hashtagsFormatted: result.hashtags,
        processedMedia: uploadedFiles.map(m => m.url),
        originalMedia: uploadedFiles.map(m => m.url),
        processedAt: new Date().toISOString(),
        autoGenerated: true,
        voiceEdited: false,
      };
      
      await sessionService.storeProcessedContent(sessionId, autoGeneratedContent);
      
      logger.info(`Fast-generated content stored for session ${sessionId}`, {
        captionLength: result.caption.length,
        hashtagCount: result.hashtags.split(' ').length,
      });
    } catch (error) {
      logger.error('Fast-generation error:', error);
      // Continue even if auto-generation fails
    }

    // Convert uploaded files to base64 for response
    const fs = require('fs');
    const path = require('path');
    const imagesWithBase64 = [];
    
    for (const file of uploadedFiles) {
      try {
        const filePath = path.join(process.cwd(), file.url);
        if (fs.existsSync(filePath)) {
          const imageBuffer = fs.readFileSync(filePath);
          const base64 = imageBuffer.toString('base64');
          const mimeType = file.mimeType;
          
          imagesWithBase64.push({
            url: file.url,
            base64: `data:${mimeType};base64,${base64}`,
            mimeType: mimeType,
          });
        }
      } catch (error) {
        logger.error(`Error converting image to base64: ${file.url}`, error);
      }
    }

    // Return simple response matching sync API format
    res.status(201).json({
      success: true,
      data: {
        sessionId,
        images: imagesWithBase64,
        caption: autoGeneratedContent?.caption || null,
        hashtags: autoGeneratedContent?.hashtagsFormatted || '',
      },
    });
  } catch (error) {
    logger.error('Upload media error:', error);
    next(error);
  }
};

/**
 * Get uploaded media for session
 */
const getSessionMedia = async (req, res, next) => {
  try {
    const session = req.session;

    res.json({
      success: true,
      data: {
        media: session.metadata.uploadedMedia,
        total: session.metadata.uploadedMedia.length,
      },
    });
  } catch (error) {
    logger.error('Get session media error:', error);
    next(error);
  }
};

/**
 * Delete media from session
 */
const deleteMedia = async (req, res, next) => {
  try {
    const { sessionId, mediaId } = req.params;
    const session = await sessionService.getSession(sessionId);

    if (!session) {
      return res.status(404).json({
        success: false,
        message: 'Session not found',
      });
    }

    // Find and remove media
    const mediaIndex = session.metadata.uploadedMedia.findIndex(
      m => m.mediaId === mediaId
    );

    if (mediaIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Media not found',
      });
    }

    const media = session.metadata.uploadedMedia[mediaIndex];

    // Delete from storage
    await storageService.deleteFile(media.url);

    // Remove from session
    session.metadata.uploadedMedia.splice(mediaIndex, 1);
    await sessionService.updateSession(sessionId, session);

    res.json({
      success: true,
      message: 'Media deleted successfully',
    });
  } catch (error) {
    logger.error('Delete media error:', error);
    next(error);
  }
};

/**
 * Edit uploaded image using AI (NanoBanana)
 */
const editImage = async (req, res, next) => {
  try {
    const { sessionId, mediaId } = req.params;
    const { editRequest, style, mood, platform } = req.body;

    if (!editRequest) {
      return res.status(400).json({
        success: false,
        message: 'Edit request is required',
      });
    }

    logger.info(`Editing image for session ${sessionId}, media ${mediaId}`);

    // Get session and find the media
    const session = await sessionService.getSession(sessionId);
    if (!session) {
      return res.status(404).json({
        success: false,
        message: 'Session not found',
      });
    }

    const media = session.metadata.uploadedMedia.find(m => m.mediaId === mediaId);
    if (!media) {
      return res.status(404).json({
        success: false,
        message: 'Media not found',
      });
    }

    // Load the image buffer from storage
    const fs = require('fs');
    const path = require('path');
    const filePath = path.join(process.cwd(), media.url);
    
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        message: 'Image file not found',
      });
    }

    const imageBuffer = fs.readFileSync(filePath);

    // Use coordinator to edit the image with AI
    const editResult = await coordinatorAgent.editImage(imageBuffer, editRequest, {
      style,
      mood,
      platform: platform || session.intent?.platform,
    });

    // Save the edited image (override the original)
    const editedFilePath = filePath; // Override the same file
    fs.writeFileSync(editedFilePath, editResult.buffer);

    logger.info(`Image edited and saved: ${editedFilePath}`);

    // Update session with edit history
    if (!session.metadata.editHistory) {
      session.metadata.editHistory = [];
    }
    session.metadata.editHistory.push({
      mediaId,
      editRequest,
      editedAt: new Date().toISOString(),
      method: editResult.method,
    });
    await sessionService.updateSession(sessionId, session);

    // Convert edited image to base64 for response
    const base64 = editResult.buffer.toString('base64');
    const mimeType = media.mimeType;

    res.json({
      success: true,
      data: {
        mediaId,
        editApplied: editResult.editApplied,
        method: editResult.method,
        url: media.url,
        base64: `data:${mimeType};base64,${base64}`,
        editedAt: editResult.timestamp,
      },
      message: 'Image edited successfully using AI',
    });
  } catch (error) {
    logger.error('Edit image error:', error);
    next(error);
  }
};

module.exports = {
  uploadMedia,
  getSessionMedia,
  deleteMedia,
  editImage,
};

